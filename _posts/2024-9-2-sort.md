---
title: sort
date: 2024-9-2
---

# 排序思路总结

### 1. 冒泡排序（Bubble Sort）
- **思路**：通过重复遍历数组，比较相邻的元素并交换它们的位置，使得较大的元素逐步“冒泡”到数组的末尾。
- **适合场景**：教学

### 2. 选择排序（Selection Sort）
- **思路**：每次从未排序部分中选择最小（或最大）元素，将其放到已排序部分的末尾，直到所有元素排序完成。
- **适合场景**：教学

### 3. 插入排序（Insertion Sort）
- **思路**：将数组分为已排序和未排序两部分，逐步将未排序部分的元素插入到已排序部分的合适位置。
- **适合场景**：适合小规模数据或部分已排序的数据，稳定性好。

### 4. 快速排序（Quick Sort）
- **思路**：选择一个“基准”元素，将数组分成两部分，小于基准的元素在左边，大于基准的元素在右边，递归排序两部分。
- **适合场景**：适合大规模数据，常用且效率高，但不稳定。

### 5. 归并排序（Merge Sort）
- **思路**：将数组分成两半，分别排序，然后合并两个已排序的部分，形成一个完整的排序数组。
- **适合场景**：适合大规模数据，稳定，适用于链表等数据结构。

### 6. 希尔排序（Shell Sort）
- **思路**：对数组进行分组，使用插入排序对每组进行排序，然后逐步减少分组的间隔，最终对整个数组进行排序。
- **适合场景**：适合中等规模数据，能有较好的性能提升。

### 7. 堆排序（Heap Sort）
- **思路**：将数组视为一棵完全二叉树，构建一个最大堆（或最小堆），然后 repeatedly 取出堆顶元素并重新调整堆，直到排序完成。
- **适合场景**：适合大规模数据，不稳定，且不需要额外的空间。

### 8. 计数排序（Counting Sort）
- **思路**：通过统计每个元素出现的次数，利用这些信息直接生成排序后的数组，适用于范围较小的整数。
- **适合场景**：适合范围小且数据量大的整数排序，非比较排序。

### 9. 桶排序（Bucket Sort）
- **思路**：将元素分到多个桶中，然后对每个桶内部进行排序，最后将所有桶的元素合并，适用于均匀分布的数据。
- **适合场景**：适合均匀分布的数据，常与其他排序结合使用。

### 10. 基数排序（Radix Sort）
- **思路**：通过逐位比较元素的数字，从最低位到最高位进行排序，适用于整数或字符串。
- **适合场景**：适合整数或字符串，且数据范围较小。

