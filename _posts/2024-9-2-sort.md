---
title: sort
date: 2024-9-2
---

# 排序思路总结

### 1. 冒泡排序（Bubble Sort）
- **思路**：通过重复遍历数组，比较相邻的元素并交换它们的位置，使得较大的元素逐步“冒泡”到数组的末尾。
- **适合场景**：教学
- **稳定**
- **最佳情况：有序数组，一次遍历时间复杂度为O(n**)

### 2. 选择排序（Selection Sort）
- **思路**：每次从未排序部分中选择最小（或最大）元素，将其放到已排序部分的末尾，直到所有元素排序完成。
- **适合场景**：教学
- **不稳定**：排序基于跨越远距离的元素交换或赋值，会改变原来元素的相对顺序

### 3. 插入排序（Insertion Sort）
- **思路**：将数组分为已排序和未排序两部分，逐步将未排序部分的元素插入到已排序部分的合适位置。
- **适合场景**：适合**小规模数据****或部分已排序**的数据，稳定性好。
- **稳定**：基于元素的赋值而非交换
- **缺点：当插入较小元素时，需要较多的比较次数和移动元素次数，影响性能**

### 4. 希尔排序（Shell Sort）

​		

- **思路**：对数组进行分组，使用插入排序对每组进行排序，然后逐步减少分组的间隔，最终对整个数组进行排序。
- **适合场景**：适合**中等规模数据**，能有较好的性能提升。
- **优点：一次性跨越远距离将较小数据插入到前面的位置，舍弃了稳定性，提升性能**
- **缺点：小数据集不如插入，大数据集不如快排归并**

### 5. 快速排序（Quick Sort）
- **思路**：选择一个“基准”元素，将数组分成两部分，小于基准的元素在左边，大于基准的元素在右边，递归排序两部分。
- **适合场景**：适合**大规模数据**，常用且**效率高**，但**不稳定**。
- 核心操作：**分区**
- **时间复杂度**:
  - 最佳情况 O(n log n)
    - 当每次选择的基准能够将数组均匀分割时，递归深度为 log n，每层操作需要 O(n) 的时间。
  - 平均情况 O(n log n)
    - 在随机情况下，基准选择能够比较均匀地分割数组。
  - 最坏情况 O(n²)
    - 当数组已经是有序的，或者总是选择到最小或最大元素作为基准时，导致分割不均匀，递归深度达到 n。
- 最主要缺点：快排的性能最坏时会滑向👆，而且相比归并排序的递归实现的空间占用O(logn)，O(n) 的空间复杂度更容易出现栈溢出 

### 6. 归并排序（Merge Sort）

- **思路**：将数组分成两半，分别排序，然后合并两个已排序的部分，形成一个完整的排序数组。

- **适合场景**：适合**大规模数据**，**稳定**，适用于链表等数据结构。

- 核心操作：**合并**

- **时间复杂度**: 

  ​	无论输入数组的初始状态如何，归并排序都需要进行 log n 次分割，并且每次合并操作的复杂度为 O(n)，因此时间复杂度始终是 O(n log n)。

  

### 7. 堆排序（Heap Sort）
- **思路**：将数组视为一棵完全二叉树，构建一个最大堆（或最小堆），然后 repeatedly 取出堆顶元素并重新调整堆，直到排序完成。

- **适合场景**：适合大规模数据，**不稳定**，且不需要额外的空间。

- 时间复杂度：与归并类似，都是按照既定的流程完成数组的排序，所以输入数据的质量对堆排序没有影响，在各种情况下，堆排序的时间复杂度都是O(nlogn)，这得益于完全二叉树的性质，高度控制在 logn, 最坏情况下将根节点交换至叶子节点次数等于该高度

  ​	

### 8. 计数排序（Counting Sort）
- **思路**：通过统计每个元素出现的次数，利用这些信息直接生成排序后的数组，适用于范围较小的整数。
- **适合场景**：适合范围小且数据量大的整数排序，非比较排序。

### 9. 桶排序（Bucket Sort）
- **思路**：将元素分到多个桶中，然后对每个桶内部进行排序，最后将所有桶的元素合并，适用于均匀分布的数据。
- **适合场景**：适合均匀分布的数据，常与其他排序结合使用。

### 10. 基数排序（Radix Sort）
- **思路**：通过逐位比较元素的数字，从最低位到最高位进行排序，适用于整数或字符串。
- **适合场景**：适合整数或字符串，且数据范围较小。

